
* Core
** Windows and Frames
#+begin_src emacs-lisp 
  (setq pop-up-windows t
        split-window-preferred-function 'split-window-sensibly
        split-width-threshold nil
        split-height-threshold nil)
  
  (if nil
      (defun dan/display-buffer-whole-frame (buffer &rest ignored)
        ;; (switch-to-buffer buffer)
        (delete-other-windows))
  
    (setq special-display-function 'dan/display-buffer-whole-frame)
  
    ;; (setq special-display-function (lambda (buffer &rest ignored) (switch-to-buffer buffer) (delete-other-windows))))
    (setq special-display-function (lambda (buffer &rest ignored) (delete-other-windows)))
  )
#+end_src

*** Faces
#+begin_src emacs-lisp :tangle no
  ;; (custom-set-faces
  ;;  ;; custom-set-faces was added by Custom.
  ;;  ;; If you edit it by hand, you could mess it up, so be careful.
  ;;  ;; Your init file should contain only one such instance.
  ;;  ;; If there is more than one, they won't work right.
  ;;  '(default ((t 
  ;;              (:inherit nil :stipple nil :background "Grey15" :foreground "Grey"
  ;;                        :inverse-video nil :box nil :strike-through nil :overline nil
  ;;                        :underline nil :slant normal :weight normal :height 100
  ;;                        :width normal :foundry "unknown" :family "DejaVu Sans Mono"))))
  ;;              '(gnus-cite-1 ((((class color) (background light)) (:foreground "deep sky blue")))))
#+end_src
** Outline
  [[gnus:org#87zlb6vt8m.fsf@mundaneum.com][Email from Sébastien Vauban: {Orgmode} Re: org-style foldin]]
#+begin_src emacs-lisp
  (defun dan/prompt-for-outline-regexp (new-regexp)
    "ask the user for a local value of outline-regexp in this buffer"
    (interactive "Outline regexp: ")
    (set (make-local-variable 'outline-regexp) new-regexp))
  
  ;; (global-set-key (kbd "<f9>") 'prompt-for-outline-regexp)
  
  (defun dan/th-outline-regexp ()
   "Calculate the outline regexp for the current mode."
   (let ((comment-starter (replace-regexp-in-string
                           "[[:space:]]+" "" comment-start)))
     (when (string= comment-start ";")
       (setq comment-starter ";;"))
     (concat "^" comment-starter "\\*+")))
  
  (defun dan/th-outline-minor-mode-init ()
    (interactive)
    (setq outline-regexp (th-outline-regexp))
  
    ;; highlight the headings
    ;; see http://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html
    ;; use M-x customize-apropos face to customize faces
    ;; to find the corresponding face for each outline level see org-faces.el
    (let ((heading-1-regexp (concat (substring outline-regexp 0 -1) "\\{1\\} \\(.*\\)"))
          (heading-2-regexp (concat (substring outline-regexp 0 -1) "\\{2\\} \\(.*\\)"))
          (heading-3-regexp (concat (substring outline-regexp 0 -1) "\\{3\\} \\(.*\\)"))
          (heading-4-regexp (concat (substring outline-regexp 0 -1) "\\{4,\\} \\(.*\\)"))
          )
      (font-lock-add-keywords
       nil
       `((,heading-1-regexp 1 'org-level-1 t)
         (,heading-2-regexp 1 'org-level-2 t)
         (,heading-3-regexp 1 'org-level-3 t)
         (,heading-4-regexp 1 'org-level-4 t)))))
  
  ;; (add-hook 'outline-minor-mode-hook
  ;;           'th-outline-minor-mode-init)
  
  
  ;; (org-level-1 ((t (:foreground "cornflower blue" :weight bold :height 1.8 :family "Arial"))))
  ;; (org-level-2 ((t (:foreground "LimeGreen" :weight bold :height 1.6 :family "Arial"))))
  ;; (org-level-3 ((t (:foreground "orange" :weight bold :height 1.3 :family "Arial"))))
  
  ;;* non-elisp modes
  (add-hook 'outline-minor-mode-hook
    (lambda ()
      (define-key outline-minor-mode-map [(control tab)] 'org-cycle)
      (define-key outline-minor-mode-map [(backtab)] 'org-global-cycle))) ;; (shift tab) doesn't work
  
  (add-hook 'outline-mode-hook
    (lambda ()
      (define-key outline-mode-map [(tab)] 'org-cycle)
      (define-key outline-mode-map [(backtab)] 'org-global-cycle))) ;; (shift tab) doesn't work
  
  (defun dan/set-up-outline-minor-mode (local-outline-regexp)
    (when local-outline-regexp
      (setq outline-regexp local-outline-regexp))
    ;; how does scope work in lisp? What if the function arg were named
    ;; outline-regexp?
    (outline-minor-mode t)
    (org-overview) ;; hack -- in this context, org-content only seems to
    ;; work after org-overview
    (org-content))
  
  (defun dan/maybe-org-cycle ()
    "Cycle visibility if in a heading line; otherwise do what TAB would have done"
    (if (looking-at-p outline-regexp) (org-cycle)
      ;; else what?
  ))
  
  ;; where are the regexps used by font-lock kept? Should use them
  ;; rather than random home-grown ones.
  (add-hook 'ess-mode-hook
            (lambda () 
              (unless (eq noweb-code-mode 'R-mode)
                ;; (dan/set-up-outline-minor-mode "^\\(###\\|[a-zA-Z._[\"][a-zA-Z._0-9[\"]* *<- *function\\)")
                ;; (dan/set-up-outline-minor-mode "^[a-zA-Z._[\"][a-zA-Z._0-9[\"]* *<- *function")
		(dan/set-up-outline-minor-mode "^[a-zA-Z._][a-zA-Z._0-9]* *<- *function")
		)))
  ;; (add-hook 'c-mode-hook
  ;;        (lambda () (dan/set-up-outline-minor-mode nil)))
  ;;                    "\\(void\\|int\\|double\\|char\\|struct\\|static\\|const\\)")))
  ;; (add-hook 'emacs-lisp-mode-hook 'th-outline-minor-mode-init)
  
  (add-hook 'emacs-lisp-mode-hook
            (lambda () (dan/set-up-outline-minor-mode "\\((\\|;;;\\)")))
  (add-hook 'python-mode-hook
            (lambda () (dan/set-up-outline-minor-mode "\\( *def \\|if \\|class \\|##\\)")))
  (add-hook 'bibtex-mode-hook
            (lambda () (dan/set-up-outline-minor-mode "@")))
  
  ;; It's possible I should be using outline-magic
  ;; This is the configuration recommended outline-magic.el
  ;;
  ;; (add-hook 'outline-mode-hook 
  ;;           (lambda () 
  ;;             (require 'outline-cycle)))
              
  ;; (add-hook 'outline-minor-mode-hook 
  ;;           (lambda () 
  ;;             (require 'outline-magic)
  ;;             (define-key outline-minor-mode-map [(f10)] 'outline-cycle)))
#+end_src
** Completion
#+begin_src emacs-lisp
  ;; ;; Things that I'm not really interested in seeing in emacs
  ;; ;; (you can still open them explicitly)
  (setq dan/ignored-extensions
        '(".html" ".csv" ".ps" ".bst" ".cls"
          ".fdf" ".spl" ".aux" ".ppt" ".doc" ".xls" ".mp3" ".org"))
  
  (mapc (lambda(extension)
          (add-to-list 'completion-ignored-extensions extension))
          dan/ignored-extensions)
  (ido-mode t) ;; (iswitchb-mode t)
  (setq ido-separator " ")
  
  ;; As regexps, these should really have terminal $
  (mapc (lambda(extension)
          (add-to-list 'ido-ignore-buffers (regexp-quote extension))
          (add-to-list 'ido-ignore-files (regexp-quote extension)))
        dan/ignored-extensions) 
  
  (add-to-list 'ido-ignore-buffers "\\*") ;; if you want *scratch* or *R* just type it
  ;; (add-to-list 'ido-ignore-files "^[^.]+$") ;; files must have a . in their name (experimental)
#+end_src
** Comint
#+begin_src emacs-lisp
  (setq comint-input-ring-size 1024)
  
  ;; See ess-help post by M. Maechler on 23 Mar 2006
  (eval-after-load
      "comint"
    '(progn
       (setq comint-scroll-to-bottom-on-output 'others) ; not current
       ;;=default: (setq comint-scroll-to-bottom-on-input nil)
       (setq comint-scroll-show-maximum-output t) ;;; this is the key
       (define-key comint-mode-map [C-up]
         'comint-previous-matching-input-from-input)
       (define-key comint-mode-map [C-down]
         'comint-next-matching-input-from-input)
       (define-key comint-mode-map "\C-a" 'comint-bol)))
#+end_src
** Config
*** Minor modes
#+begin_src emacs-lisp 
  (show-paren-mode t)
  (winner-mode t)
  (global-font-lock-mode t)
  
  ;; (desktop-save-mode t)
  ;; (display-battery-mode t)
  ;; (global-auto-revert-mode nil)
  ;; (setq global-auto-revert-mode-text "")
#+end_src
*** Elisp programming
#+srcname: name
#+begin_src emacs-lisp 
  (setq eval-expression-debug-on-error nil)
  (setq find-function-C-source-directory "/usr/local/src/emacs/emacs-23.1/src")
#+end_src
*** Etc
#+begin_src emacs-lisp
  (setq case-fold-search nil)
  (setq default-major-mode 'org-mode)
  (setq diff-switches "-u")
  (setq frame-title-format "emacs:%b") ;;      (concat  "%b - emacs@" (system-name)))
  (setq kill-read-only-ok t)
  (setq initial-scratch-message nil)
  (setq minibuffer-message-timeout 0.5)
  (setq parens-require-spaces nil)
  (setq require-final-newline 'visit-save)
  (setq tags-file-name "~/src/.tags")
  (setq vc-follow-symlinks t)
  (setq x-alt-keysym 'meta)
  (setq backup-inhibited t)
  
  ;; (visit-tags-table tags-file-name)
  ;; (setq font-lock-always-fontify-immediately t) where did I get that from?
  
  (fset 'yes-or-no-p 'y-or-n-p) ;; http://www.xsteve.at/prg/emacs/.emacs.txt -- replace y-e-s by y
  (put 'narrow-to-region 'disabled nil)
  
  ;; put back-up files in a single (invisible) directory in the original file's directory
  ;; (setq backup-directory-alist '(("." . ".emacs-backups")))
  ;; put back-up files in a single (invisible) directory in home directory -- doesn't work
  ;; (setq backup-directory-alist '(("~/.emacs-backups"))) 
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  
  ;; (setq kill-buffer-query-functions '(lambda() t))
  
  ;; (transient-mark-mode t) ;; something turns it off
#+end_src
*** Safe local variables
#+begin_src emacs-lisp :results pp
  (setq safe-local-variable-values
        '(
          (org-babel-default-header-args
           (:tangle . "wtccc2-pca.py")
           (:exports . "code"))
          (org-babel-default-header-args
           (:tangle . "yes"))
          (org-babel-default-header-args
           (:results . "replace output")
           (:session . "*R - jsmr*")
           (:exports . "none"))
          (org-babel-default-header-args
           (:results . "replace output")
           (:session . "*R: wtccc2*")
           (:exports . "none"))
          (noweb-default-code-mode . R-mode)
          (org-src-preserve-indentation . t)
          (org-edit-src-content-indentation . 0)
          (outline-minor-mode)))
#+end_src
*** Hooks
:PROPERTIES:
:ID: 20eb729f-8509-4e78-bf5a-9b250b189b9b
:END:
#+begin_src emacs-lisp
  ;; This doesn't work with org-src-mode code buffers as their
  ;; buffer-file-name doesn't correspond to a file
  ;; (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  ;; (add-hook 'after-change-major-mode-hook 'dan/toggle-mode-line)
#+end_src
** Appearance
#+begin_src emacs-lisp
  (defun dan/sanitise-faces ()
    (interactive)
    ;; (set-face-background 'region (face-background 'default)) ;; don't highlight region
    (set-face-background 'fringe (face-background 'default)) ;; don't have different color fringe
    ;; (set-face-background 'highlight (face-background 'default))
    ;; (set-face-foreground 'highlight (face-foreground 'font-lock-comment-face))
    ;; (set-face-foreground 'cursor (face-foreground 'font-lock-comment-face))
    ;; (set-cursor-color (face-foreground 'font-lock-comment-face))
    (set-face-attribute 'org-hide nil
                        :foreground
                        (face-attribute 'default :background))
    (font-lock-fontify-buffer))
  
  (defun dan/set-show-paren-style ()
    (interactive)
    (setq show-paren-delay .125)
    (setq show-paren-style 'parenthesis)
    ;; use these in a mode hook function
    ;; (make-variable-buffer-local 'show-paren-mode)
    ;; (show-paren-mode t)
    (set-face-attribute 'show-paren-match-face nil :weight 'extra-bold)
    (set-face-background 'show-paren-match-face (face-background 'default))
    (if (boundp 'font-lock-comment-face)
        (set-face-foreground 'show-paren-match-face 
                             (face-foreground 'font-lock-comment-face))
      (set-face-foreground 'show-paren-match-face 
                           (face-foreground 'default))))
        
  (add-hook 'find-file-hook 'dan/sanitise-faces)
  (add-hook 'find-file-hook 'dan/set-show-paren-style)
  
  (setq dan/custom-appearance nil)
  (if dan/custom-appearance
      (if (not window-system)
          (custom-set-faces
           '(mode-line ((t (:foreground "red" :inverse-video nil))))
           '(org-agenda-date-weekend ((t (:foreground "red"))) t)
           '(org-hide ((((background light)) (:foreground "black")))))
        (progn
          (add-to-list 'load-path "/usr/local/src/emacs/color-theme-6.6.0")
          (require 'color-theme)
          (eval-after-load "color-theme"
            '(progn
               (color-theme-initialize)
               (color-theme-charcoal-black))))))
#+end_src
*** Vanilla
#+begin_src emacs-lisp
  (nconc default-frame-alist '((cursor-type . bar)))
  (setq inhibit-startup-message t)
  (blink-cursor-mode -1)
#+end_src
*** Save faces
#+begin_src emacs-lisp
    (defun dan/save-faces (&optional restore-p)
      (interactive "P")
      (let ((faces (face-list)) orig)
        (dolist (face (face-list))
          (unless (string-match "__original$" (symbol-name face))
            (setq orig (intern (concat (symbol-name face) "__original")))
            (if restore-p
                (condition-case nil
                    (copy-face orig face)
                  (error "Failed to restore face %s from %s" face orig))
              (condition-case nil
                  (copy-face face orig)
                (error "Failed to save face %s as %s" face orig)))))))
    
    (dan/save-faces)
  
  (setq color-theme-is-cumulative t)
#+end_src

*** Transparency
http://www.emacswiki.org/emacs/TransparentEmacs
#+begin_src emacs-lisp
   ;;(set-frame-parameter (selected-frame) 'alpha '(<active> [<inactive>]))
   (setq dan/frame-alpha '(90 50)) ;; 85 50

  (set-frame-parameter (selected-frame) 'alpha dan/frame-alpha)
  (add-to-list 'default-frame-alist (cons 'alpha dan/frame-alpha))

  ;; no transparency:
  ;; (set-frame-parameter (selected-frame) 'alpha '(100 100))
  ;; (add-to-list 'default-frame-alist '(alpha 100 100))
  
  ;; You can use the following snippet after you’ve set the alpha as above to assign a toggle to “C-c t”:
  
   (eval-when-compile (require 'cl))
   (defun dan/toggle-transparency ()
     (interactive)
     (if (/=
          (cadr (find 'alpha (frame-parameters nil) :key #'car))
          100)
         (set-frame-parameter nil 'alpha '(100 100))
       (set-frame-parameter nil 'alpha '(85 60))))
   (global-set-key (kbd "C-c t") 'toggle-transparency)
#+end_src
  (defun dan/org-src-mode-hook ()
    (outline-minor-mode -1)
    (if (eq major-mode 'python-mode)
        (setq python-indent 4)))
  
  (add-hook 'org-src-mode-hook 'dan/org-src-mode-hook)
  ;; (remove-hook 'org-src-mode-hook 'dan/org-src-mode-hook)
  
  (add-to-list 'org-src-lang-modes '("C" . c))
  
  (setq org-hide-block-startup t)
  
  ;; (setq org-src-window-setup 'reorganize-frame) ;; 'current-window 'other-window 'other-frame 'reorganize-frame
  (setq org-src-window-setup 'current-window) ;; 'current-window 'other-window 'other-frame 'reorganize-frame
  
  
  (setq org-src-ask-before-returning-to-edit-buffer nil)
  
  (define-key org-src-mode-map [C-tab] 'org-edit-src-exit)* Internal modules
** Info
#+begin_src emacs-lisp :tangle no
  (add-to-list 'Info-directory-list "/usr/share/info/emacs-snapshot")
#+end_src
** Dired
#+begin_src emacs-lisp
  (setq dired-listing-switches "-lAX")
  (setq dired-no-confirm
        '(byte-compile chgrp chmod chown compress copy hardlink load move print shell symlink
                       touch uncompress))
  
  (defun dan/dired-delete-total-line ()
    (let ((bro buffer-read-only)
          (kill-whole-line t))
      (save-excursion
        (goto-char (point-min))
        (forward-line)
        (when (looking-at "^ *total used in directory")
          (if bro (setq buffer-read-only nil))
          (kill-line)
          (setq buffer-read-only bro)))))
  
  (add-hook 'dired-after-readin-hook 'dan/dired-delete-total-line)
  
#+end_src
*** Dired for git repo
[[mairix:t:@@m1630s27or.fsf@65-070.eduroam.rwth-aachen.de][Email from Andrea Crotti: Re: Simple useful function]]
#+begin_src emacs-lisp
  (defun dan/dired-git-files ()
    (interactive)
    (dired (cons (format "%s [git]" default-dqirectory)
                 (dan/ls-git-files))))
  
  (defun dan/ls-git-files ()
    (if (file-exists-p ".git")
        (split-string (shell-command-to-string "git ls-files"))
      (error "Not a git repo")))
#+end_src
** Buffer lists
*** Ibuffer
#+begin_src emacs-lisp
  (setq ibuffer-show-empty-filter-groups nil)
  
  (defalias 'list-buffers 'ibuffer)
    
  (setq ibuffer-saved-filter-groups
        '(("default"      
           ("VBPL"
            (or
             (name . "Papers/structure")
             (name . "^dan\.bib$")))
           ("PoBI"
            (name . "pobi"))
           ("WTCCC2"
            (name . "wtccc2"))
           ("MSG"
            (name . "simsec")
            (name . "Papers/msg"))
           ("shellfish"
            (name . "shellfish"))
           ("Org-babel"
            (name . "babel"))
           ("Org-mode"
            (or (name . "org-mode")
                (name . "^org\.org$")))
           ("Org-buffers"
            (name . "org-buffers"))
           ("Email"
            (or  ;; mail-related buffers
             (mode . message-mode)
             (mode . mail-mode)
             (mode . gnus-group-mode)
             (mode . gnus-summary-mode)
             (mode . gnus-article-mode)
             (name . "newsrc")))
           ("Elisp"
            (or
             (name . "config/emacs")
             (name . "^\\*scratch\\*$")
             (name . "^\\*eshell\\*$")))
           ("Emacs"
            (or
             (name . "^\\*scratch\\*$")
             (name . "^\\*Messages\\*$")))
           ("Org"
            (mode . org-mode))  
           ("ERC"
            (mode . erc-mode))
           ("Etc"
            (name . ".")))))
  
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src

*** Buffer Menu
#+begin_src emacs-lisp
  (setq Buffer-menu-sort-column 4)
#+end_src
** Recentf
#+begin_src emacs-lisp
  (recentf-mode t)
  ;; recentf-exclude
  (setq recentf-max-saved-items nil)
#+end_src

** Message Mode
#+begin_src emacs-lisp 
  (setq message-send-mail-partially nil)
#+end_src
       
** Flyspell
#+begin_src emacs-lisp
  (setq flyspell-issue-message-flag nil)
#+end_src
** Language modes
*** Elisp
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'pretty-lambdas)
#+end_src

*** C & C++
#+begin_src emacs-lisp
  ;; Dan Feb 2006: See http://www.xemacs.org/Links/tutorials_1.html
  (defun dan/c-c++-mode-hook ()
    "Dan's local settings for c-mode and c++-mode"
    ;; add font-lock to function calls (but also gets if() and while() etc)
    ;; (font-lock-add-keywords
    ;; ? ?nil `(("\\([[:alpha:]_][[:alnum:]_]*\\)(" ?1 font-lock-function-name-face)))
    (setq c-basic-offset 4)
    (setq line-number-mode t))
  
  ;; (add-hook 'c-mode-hook 'c++-mode) ;; I want C++ comments, but that seems a bit heavy-handed?
  (add-hook 'c-mode-hook 'dan/c-c++-mode-hook)
  (add-hook 'c++-mode-hook 'dan/c-c++-mode-hook)
  
  (setq compilation-read-command nil)
#+end_src

*** Lua
#+begin_src emacs-lisp
  (setq auto-mode-alist (cons '("\\.lua$" . lua-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.pyw$" . python-mode) auto-mode-alist))
  ;; (autoload 'lua-mode "/usr/local/src/lua-mode/lua-mode" "Lua editing mode." t)
  ;; (add-hook 'lua-mode-hook 'turn-on-font-lock)
#+end_src
*** LaTeX
#+begin_src emacs-lisp
  (require 'tex-mode)
  (add-hook 'latex-mode-hook 'reftex-mode)
#+end_src
*** TeXinfo
#+begin_src emacs-lisp
(require 'texinfo)
#+end_src

** Browser
#+begin_src emacs-lisp
  ;; http://flash.metawaredesign.co.uk/2/.emacs
  (if window-system
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "google-chrome"))
  ;; (setq browse-url-browser-function 'browse-url-firefox)
  ;; (setq browse-url-browser-function 'w3m-browse-url)
  ;; (setq browse-url-firefox-new-window-is-tab t)
#+end_src
** Non-default
*** Saveplace
#+begin_src emacs-lisp :tangle no
  (require 'saveplace)
  (setq-default save-place t)
  
  (add-hook 'org-mode-hook
            (lambda ()
              (when (outline-invisible-p)
                (save-excursion
                  (outline-previous-visible-heading 1)
                  (org-show-subtree)))))
#+end_src
* External modules
** Load path
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs")
#+end_src
** Buffer-join
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/buffer-join")
  ;; (require 'buffer-join)
#+end_src

** Color-theme
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/color-theme-6.6.0")
  (require 'color-theme)
  ;; (require 'zenburn)
  ;; (require 'color-theme-chocolate-rain)
#+end_src

** Elpa
#+begin_src emacs-lisp
  ;;; This was installed by package-install.el.
  ;;; This provides support for the package system and
  ;;; interfacing with ELPA, the package archive.
  ;;; Move this code earlier if you want to reference
  ;;; packages in your .emacs.
  (when
      (load
       (expand-file-name "~/.emacs.d/elpa/package.el"))
    (package-initialize))
#+end_src
** ESS
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/ess/lisp")
  (require 'ess-site)
  
  ;; (require 'ess-eldoc)
  
;; (setq ess-ask-for-ess-directory nil)
  (setq inferior-R-args "--no-save --no-restore-data --silent")
  (setq safe-local-variable-values '((noweb-default-code-mode . R-mode) (outline-minor-mode)))
  (autoload 'noweb-mode "noweb-mode" "Editing noweb files." t) ;; see noweb-mode.el in ESS;
  (setq auto-mode-alist (append (list (cons "\\.nw$" 'noweb-mode))
                                auto-mode-alist))
  
  ;; (defun dan/ess-and-iess-mode-hook ()
  ;;   (setq ess-function-template " <- function() {\n\n}\n")
  ;;   (mapc (lambda (pair) (local-set-key (car pair) (cdr pair)))
  ;;        dan/ess-and-iess-keybindings))
  
  (defun dan/ess-mode-hook ()
    (ess-set-style 'C++))
  
  ;; (add-hook 'ess-mode-hook 'dan/ess-and-iess-mode-hook)
  ;; (add-hook 'inferior-ess-mode-hook 'dan/ess-and-iess-mode-hook)
  (add-hook 'ess-mode-hook 'dan/ess-mode-hook)
  
  (setq ess-eval-visibly-p nil)
  
  
  ;;                                 DEF GNU BSD K&R C++
  ;; ess-indent-level                  2   2   8   5   4
  ;; ess-continued-statement-offset    2   2   8   5   4
  ;; ess-brace-offset                  0   0  -8  -5  -4
  ;; ess-arg-function-offset           2   4   0   0   0
  ;; ess-expression-offset             4   2   8   5   4
  ;; ess-else-offset                   0   0   0   0   0
  ;; ess-close-brace-offset            0   0   0   0   0
#+end_src

*** Add R builtins to font lock

#+source: R-builtins
#+begin_src R
  obj <- unlist(sapply(c("package:base","package:stats","package:utils","package:grDevices"), objects, all.names=TRUE))
  re <- "(^[^.[:alpha:][:digit:]]|<-|__)"  ## to remove "weird" functions
  obj[-grep(re, obj)]
#+end_src

#+begin_src emacs-lisp :var R-builtins=R-builtins() :tangle no
  (add-to-list
   'ess-R-mode-font-lock-keywords
   (cons 
    (concat "\\<" (regexp-opt (mapcar #'car R-builtins) 'enc-paren) "\\>")
    'font-lock-function-name-face))
#+end_src

*** Etc
#+begin_src emacs-lisp :tangle no
  (defun dan/ess-execute-command-on-region (cmd)
    (interactive "sEnter function name: \n")
    (ess-execute
     (concat cmd "(" (buffer-substring (point) (mark)) ")")))
#+end_src
** Gnus
*** General
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/emacs/gnus/lisp")
  (require 'gnus-load)
  
  (require 'nnmairix)
  (setq user-mail-address "davison@stats.ox.ac.uk") ;; dandavison7@gmail.com
  (setq user-full-name "Dan Davison")
  
  (setq gnus-select-method 
        '(nnimap "dc"
                 (nnimap-address "localhost")
                 (nnimap-authinfo-file "~/config/email/authinfo")))
  
  (setq gnus-secondary-select-methods
        '((nntp "news.gmane.org")
          (nntp "news.eternal-september.org")))
  
  (setq gnus-save-newsrc-file nil)
  (setq gnus-play-startup-jingle t)
  (setq gnus-novice-user nil)
  (setq gnus-expert-user t)
  
  ;; (setq gnus-always-read-dribble-file t) TMP
  
  ;; ;; (mail-source-delete-incoming t)
  
  
  ;;------------------------------------------------------------------------------------------
  ;;;
  ;;; Misc
  ;;;
  ;; http://people.orangeandbronze.com/~jmibanez/dotgnus.el
  
  ;; w3m absent on dell, atm
  ;; (require 'w3m-load)
  ;; (setq mm-text-html-renderer 'w3m)
  ;; (setq mm-text-html-renderer 'html2text)
  
  ;; http://flash.metawaredesign.co.uk/2/.gnus
  ;; (add-hook 'gnus-group-mode-hook 'color-theme-charcoal-black)
  
  ;;(setq gnus-read-active-file nil)
  ;;(setq gnus-check-new-newsgroups nil)
  
  
  ;; trying to get rid of duplicates don't know why they occur -- seems
  ;; that repeated downloads from server sometimes gets previously
  ;; downloaded messages
  ;; (setq gnus-suppress-duplicates nil)
  ;; (setq nnmail-treat-duplicates nil)
  ;; (setq gnus-summary-ignore-duplicates t)
  
  (defun ded/mml-fill-paragraph ()
    "Fill paragraph, but without messing with the email header"
    (interactive)
    (let ((beg (save-excursion
                 (when (search-backward "--text follows this line--" nil t)
                   (forward-line 1) (point)))))
      (when beg
        (narrow-to-region beg (point-max))
        (fill-paragraph)
        (widen))))
  
  ;;
  ;;-----------------------------------------------------------------------------------------
  
  (defun dan/gnus-summary-delete-article ()
    ;; How come this deletes all articles in the active region?
  
    (interactive)
    (save-window-excursion
      (gnus-summary-delete-article)
      (gnus-summary-next-article)))
    
  ;;;
  ;;; Expiry
  ;;;
  ;; http://www.xemacs.org/Links/tutorials_3.html
  ;; turn off expiry
  (remove-hook 'gnus-summary-prepare-exit-hook 'gnus-summary-expire-articles)
  
  ;; http://flash.metawaredesign.co.uk/2/.gnus
  ;; Don't make email expirable by default
  (remove-hook 'gnus-mark-article-hook
               'gnus-summary-mark-read-and-unread-as-read)
  ;; (add-hook 'gnus-mark-article-hook 'gnus-summary-mark-unread-as-read) ;; don't get it
  
  ;; Only mails in these groups will expire, meaning they'll be deleted after a
  ;; week so long as I've read them.
  (setq gnus-auto-expirable-newsgroups nil)
  ;; "junk\\|forums\\|gentoo-announce\\|bradsucks\\|bots\\|system\\|nnrss:.*")
  
  ;; But when I mark stuff as expireable, delete it immediately
  
  ;; (setq nnmail-expiry-wait 'immediate) ;;TMP
  
  ;; TMP
  ;; (setq gnus-parameters
  ;;       '((".*INBOX.*"
  ;;          (expiry-wait . 'immediate))))
  
  ;;
  ;;------------------------------------------------------------------------------------------
  ;;;
  ;;;
#+end_src
*** Sending
#+begin_src emacs-lisp
  (setq
   mail-user-agent 'message-user-agent ;; so that org-mime-org-buffer-htmlize uses message-mode
   send-mail-function 'sendmail-send-it ;; generates properly-formed email and sends it with
   sendmail-program "~/bin/sendmail-dan" ;; passes email over ssh to remote sendmail in Oxford
   gnus-message-archive-group "nnimap+dc:email" ;; save outgoing mail into my default mail box
   )
#+end_src

*** Group buffer
#+begin_src emacs-lisp
  (defun dan/gnus-group-sort (info1 info2)
    "Sort alphabetically."
    (cond
     ((string= info1 "email") nil)
     ((string= info2 "email") t)
     (t (not (gnus-group-sort-by-alphabet info1 info2)))))
  
  (setq gnus-group-sort-function 'dan/gnus-group-sort)
#+end_src

*** Summary buffer
#+begin_src emacs-lisp
  ;;; Summary Buffer
  ;;;
  (when nil
    (add-hook 'gnus-summary-prepare-hook 
              (lambda () (end-of-buffer) (forward-line -1)))
  
    (add-hook 'gnus-summary-prepared-hook 
              (lambda () (end-of-buffer) (forward-line -1)))
    )
  
  (setq gnus-thread-sort-functions
        '(gnus-thread-sort-by-number
          gnus-thread-sort-by-most-recent-date))
  
  (setq gnus-summary-thread-gathering-function
        'gnus-gather-threads-by-references)
  
  (setq gnus-user-date-format-alist
        '(((gnus-seconds-today) . "    %k:%M")
          (604800 . "%a %k:%M")
          ((gnus-seconds-month)
           . "%a %d")
          ((gnus-seconds-year)
           . "%b %d")
          (t . "%b %d '%y")))
  
  (setq gnus-summary-line-format
        (concat
         "%0{%U%R%z%}"
         "%3{│%}" "%1{%~(pad-right 9)&user-date;%}" "%3{│%}" ;; date
         "  "
         "%4{%-20,20f%}"               ;; name
         "  "
         "%3{│%}"
         " "
         "%1{%B%}"
         "%s\n"))
  
  (setq gnus-summary-display-arrow t)
  
  ;; http://groups.google.com/group/gnu.emacs.gnus/browse_thread/thread/a673a74356e7141f
  (when window-system
    (setq gnus-sum-thread-tree-indent " ")
    (setq gnus-sum-thread-tree-root "♽ " )              ; ●  ⚈  
    (setq gnus-sum-thread-tree-false-root "")           ; ◯   ♽  
    (setq gnus-sum-thread-tree-single-indent "")        ; ◎ 
    (setq gnus-sum-thread-tree-vertical        "│")     ; ┆ ┋ ┆
    (setq gnus-sum-thread-tree-leaf-with-other "├─► ")  ; ┣━►   ▶
    (setq gnus-sum-thread-tree-single-leaf     "╰─► ")) ; ┗━► 
  
  ;; seems like you can't use propertize to create colour in the summary
  ;; lines. I.e. the following don't work
  (defun gnus-user-format-function-a (x)
    (string-match "From: \\(.*\\)" x)
    (propertize (match-string 1 x) 'face '(:foreground "blue")))
    
  (defun gnus-user-format-function-z (x)
    (propertize "hello" 'face '(:foreground "red")))
#+end_src
*** Correct counts
#+begin_src emacs-lisp
  ;;; dim-gnus-imap-count.el --- Dimitri Fontaine
  ;;
  ;; http://www.emacswiki.org/emacs/GnusNiftyTricks#toc2
  
  (defun dim/gnus-user-format-function-t (dummy)
    (case (car gnus-tmp-method)
      (nnimap
       (message gnus-tmp-qualified-group)
       (let ((count (dim/nnimap-request-message-count
                     gnus-tmp-qualified-group gnus-tmp-news-server)))
         (if count
             (format "%d" (car count))
           "?")))
      (t
       gnus-tmp-number-total)))
  
  (defun dim/gnus-user-format-function-y (dummy)
    (case (car gnus-tmp-method)
      (nnimap
       (let ((count (dim/nnimap-request-message-count
                     gnus-tmp-qualified-group gnus-tmp-news-server)))
         (if count
             (format "%d" (cadr count))
           "?")))
      (t
       gnus-tmp-number-of-unread)))
  
  (defvar dim/nnimap-message-count-cache-alist nil)
  
  (defun dim/nnimap-message-count-cache-clear nil
    (setq dim/nnimap-message-count-cache-alist nil))
  
  (defun dim/nnimap-message-count-cache-get (mbox &optional server)
    (when (nnimap-possibly-change-server server)
      (cadr (assoc (concat nnimap-current-server ":" mbox)
                   nnimap-message-count-cache-alist))))
  
  (defun dim/nnimap-message-count-cache-set (mbox count &optional server)
    (when (nnimap-possibly-change-server server)
      (push (list (concat nnimap-current-server ":" mbox)
                  count) nnimap-message-count-cache-alist))
    count)
  
  (defun dim/nnimap-request-message-count (mbox &optional server)
    (let ((count (or (dim/nnimap-message-count-cache-get mbox server)
                     (and (nnimap-possibly-change-server server)
                          (progn
                            (message "Requesting message count for %s..."
                                     mbox)
                            (prog1
                                (imap-mailbox-status
                                 mbox '(messages unseen) nnimap-server-buffer)
                              (message "Requesting message count for %s...done"
                                       mbox)))))))
      (when count
        (dim/nnimap-message-count-cache-set mbox count server))
      count))
  
  (add-hook 'gnus-after-getting-new-news-hook 'dim/nnimap-message-count-cache-clear)
  
  (provide 'dim-gnus-imap-count)
#+end_src

*** Article buffer
#+begin_src emacs-lisp
  ;;; Article buffer
  ;;;
  (require 'gnus-art) ; ??
  
  (setq gnus-visible-headers "^From:\\|^To:\\|^Cc:\\|^Subject:\\|^Date:\\|^User-Agent:\\|^X-Newsreader:")
  ;; Specify the order of the header lines
  (setq gnus-sorted-header-list '("^From:" "^Subject:" "^User-Agent:" "^X-Newsreader:" "^Date:"))
  
  (setq message-mode-hook (quote (orgstruct++-mode)))
  
  (setq mm-discouraged-alternatives '("text/html" "text/richtext"))
#+end_src
** Languages
#+begin_src emacs-lisp
  ;; (add-to-list 'load-path "/usr/local/src/emacs/ruby-emacs")
  (add-to-list 'load-path "/usr/local/src/emacs/gnuplot-mode.0.6.0")
  (add-to-list 'load-path "/usr/local/src/emacs/matlab")
#+end_src

** Magit
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/magit")
  (require 'magit)
  (setq egg-enable-tooltip t)
  (setq magit-save-some-buffers nil)
#+end_src
** Misc
#+begin_src emacs-lisp
    (require 'regex-tool)
    (require 'unbound)
    (require 'windresize)
    (require 'xclip)
    (require 'highlight-parentheses)
    (highlight-parentheses-mode)
    ;; (require 'ido)
    (require 'boxquote)
    ;; (load "/usr/local/src/emacs/nxhtml/autostart.el")
    ;; (load "R-anything-config")
    (require 'ssh)
    ;; (require 'google-search)
    ;; (require 'w3m)
    ;; (require 'gnuplot)
    ;; (require 'filladapt)
#+end_src

** Minimal
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/minimal")
  (require 'minimal)
  (minimal-mode t)
  (setq minimal-mode-line-background "sea green")
  (setq minimal-mode-line-inactive-background "dim grey")
#+end_src

** Org
*** Hook
#+begin_src emacs-lisp
  (defun dan/org-mode-hook-function ()
    ;; yasnippet
    (make-variable-buffer-local 'yas/trigger-key)
    (setq yas/trigger-key [tab])
    (define-key yas/keymap [tab] 'yas/next-field-group)
    (org-indent-mode t))
  
  (add-hook 'org-mode-hook 'dan/org-mode-hook-function)
#+end_src
*** Basics
#+begin_src emacs-lisp
  ;;* Org-mode settings
  
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
  
  ;; (or (server-running-p) (server-start))
#+end_src
*** Misc
#+begin_src emacs-lisp
(setq org-hide-block-startup nil)
  
  (setq org-completion-use-ido t)    
  ;; (setq org-startup-folded nil)    
  ;;* refiling
  ;; http://doc.norang.ca/org-mode.html#Refiling
  
  ;; Use IDO for target completion
  (setq org-completion-use-ido t)
  
  ;; Targets include this file and any file contributing to the agenda - up to 5 levels deep
  (setq org-refile-targets (quote ((org-agenda-files :maxlevel . 5) (nil :maxlevel . 5))))
  
  ;; Targets start with the file name - allows creating level 1 tasks
  (setq org-refile-use-outline-path 'file)
  
  ;; Targets complete in steps so we start with filename, TAB shows the next level of targets etc 
  (setq org-outline-path-complete-in-steps t)
#+end_src

*** Appearance
#+begin_src emacs-lisp
  (setq org-hide-leading-stars t)
  (setq org-hidden-keywords '(title date author))
  (copy-face 'shadow 'org-meta-line)
  (setq org-pretty-entities t)
#+end_src
**** Set outline colors
#+function: outline-colours
#+begin_src R
  require("RColorBrewer")
  brewer.pal(n=8, name="Set1")
#+end_src

#+begin_src emacs-lisp :tangle no :expand yes :var colours=outline-colours()
  (dotimes (level 8)
    (set-face-foreground
     (intern (concat "outline-" (number-to-string (1+ level))))
     (car (nth level colours))))
#+end_src

*** Structure & Navigation
#+begin_src emacs-lisp 
    ;; (setq org-odd-levels-only t)
  (setq org-empty-line-terminates-plain-lists t)
  (setq org-cycle-emulate-tab t)
  (setq org-special-ctrl-a t)
  (setq org-special-ctrl-e t)
  (setq org-return-follows-link t)
#+end_src
    See also [[mairix:t:@@20524da70908071211y4aeb4c0se9a465e2ebe27a8f@mail.gmail.com][Email from Samuel Wales: {Orgmode} Arrow + RET navigati]]

**** Speed commands
#+begin_src emacs-lisp 
  (defun dan/org-show-next-heading-tidily ()
    "Show next entry, keeping other entries closed."
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (show-children))
      (outline-next-heading)
      (unless (and (bolp) (org-on-heading-p))
        (org-up-heading-safe)
        (hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (show-children)))
  
  (defun dan/org-show-previous-heading-tidily ()
    "Show previous entry, keeping other entries closed."
    (let ((pos (point)))
      (outline-previous-heading)
      (unless (and (< (point) pos) (bolp) (org-on-heading-p))
        (goto-char pos)
        (hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (show-children)))
  
  (setq org-use-speed-commands t)
  (add-to-list 'org-speed-commands-user
               '("n" dan/org-show-next-heading-tidily))
  (add-to-list 'org-speed-commands-user 
               '("p" dan/org-show-previous-heading-tidily))
#+end_src

#+results:
| p | dan/org-show-previous-heading-tidily |
| n | dan/org-show-next-heading-tidily     |
*** Remember
#+begin_src emacs-lisp
  ;;* remember
  (org-remember-insinuate)
  (setq org-default-notes-file "~/org/etc.org")
  ;; (setq org-remember-default-headline "top")
  (setq org-remember-templates
        '(
          ("work" ?w "* TODO %?\nSCHEDULED: %^T  %i" "~/org/work.org" 'top)
          ("task" ?t "* TODO %?\nSCHEDULED: %^T\n  %i" "~/org/tasks.org" 'top)
          ("event" ?e "* %?\n%^T\n %i" "~/org/events.org" 'top)
          ("computing" ?c "* TODO %?\n  %i" "~/org/computing.org" 'top)
          ("org" ?o "* TODO %?\n  %i" "~/org/org.org")
          ("notes" ?n "* %?\n  %i" "~/org/notes.org" 'top)
          ("dbm" ?d "* TODO %?\n  %i" "~/org/dbm.org" 'top)
          ("music" ?m "* %?\n %i" "~/org/music.org" 'top)
          ("people" ?p "* TODO %?\nSCHEDULED: %^T\n  %i" "~/org/people.org" 'top)
          ("info" ?i "* %?\n %i" "~/zzz/info.org" 'top)
          ))
#+end_src

**** Quick schedule task with link
#+begin_src emacs-lisp
  (defun dan/org-schedule-task-with-link (remember-target-char &optional arg)
    "Schedule a task with a link to current buffer.
     This uses org-remember. The task is scheduled for today, and
  may use one of several remember targets"
    (interactive "cSelect remember target: [w]ork [t]asks [p]eople [c]omputing")
    (case remember-target-char
      (?w (kmacro-exec-ring-item 
           (quote ([3 108 f8 ?w return 3 12 up return return 3 3] 0 "%d")) arg))
      (?t (kmacro-exec-ring-item 
           (quote ([3 108 f8 ?t return 3 12 up return return 3 3] 0 "%d")) arg))
      (?c (kmacro-exec-ring-item 
           (quote ([3 108 f8 ?c return 3 12 up return return 3 3] 0 "%d")) arg))
      (?p (kmacro-exec-ring-item 
           (quote ([3 108 f8 ?p return 3 12 up return return 3 3] 0 "%d")) arg))))
#+end_src
	   Or maybe I can use fset like in the following?
***** Tiago Magalhaes ess-help post
	From: Luis F <respostas17@gmail.com>
	Subject: [ESS] Pushing Lines from one Window to Another
	Date: Sat, 14 Nov 2009 16:32:42 +0000
	To: ess-help@stat.math.ethz.ch
	
	Dear Mailing list,

	2 questions:

	A)
	Some time ago I asked whether it was possible to push a line from one window
	to a bottom window. (post here:
	https://stat.ethz.ch/pipermail/ess-help/2008-November/004949.html)

	Charles C. Berry suggested the following command (written by Tim Hesterberg)
	
#+begin_src emacs-lisp :tangle no
	(fset 'push-line-other-window
        "\C-@\C-e\M-w\C-n\C-a\C-xo\M->\C-y\C-m\C-xo")
	(global-set-key "\C-xp" 'push-line-other-window )
#+end_src

*** Footnotes
#+begin_src emacs-lisp
(setq org-footnote-auto-label 'plain)
#+end_src

*** Agenda
#+begin_src emacs-lisp
  ;;* agenda
  ;;  (org-defkey org-agenda-mode-map [(right)] 'forward-char)
  ;;  (org-defkey org-agenda-mode-map [(left)] 'backward-char)
  
    ;;;;
  
  
  (setq dan/org-todo-keyword "TODO")
  (setq dan/org-started-keyword "STARTED")
  (setq dan/org-done-keyword "DONE")
  (setq dan/org-cancelled-keyword "CANCELLED")
  
  (setq org-todo-keywords 
        '((sequence 
           "TODO(t!@/!@)" "STARTED(s!@/!@)" "|" "DONE(d!@/!@)" "CANCELLED(c!@/!@)")))
  ;; (setq org-todo-keyword-faces
  ;;       `(
  ;;         (,dan/org-todo-keyword . (:foreground "red" :weight bold))
  ;;         (,dan/org-started-keyword . (:foreground "darkorange" :weight bold))
  ;;         (,dan/org-done-keyword . (:foreground "green" :weight bold))
  ;;         (,dan/org-cancelled-keyword . (:foreground "black" :weight bold))
  ;;         ))
  (setq org-edit-src-persistent-message nil)
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  
  (setq org-directory "~/org")
  ;; (setq org-agenda-files (list org-directory))
  (setq org-agenda-files (list "~/org/fifa-worldcup-2010.org"))
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-ndays 30)
  (setq org-agenda-compact-blocks t)
  (setq org-deadline-warning-days 7)
  ;; (set-face-foreground 'org-agenda-date-weekend "red")
  ;; (setq org-agenda-remove-tags t) not sure why I had this
  
  (setq org-agenda-custom-commands
        '(
          ("W" "Search for work items in state" todo "TODO"
           ((org-agenda-files '("~/org/work.org"
                                "~/org/wtccc2.org"
                                "~/org/pobi.org"
                                "~/org/shellfish.org"))))
          ("T" "Search for tasks items in state" todo "TODO"
           ((org-agenda-files '("~/org/tasks.org"))))
          ("C" "Search for computing items in state" todo "TODO"
           ((org-agenda-files '("~/org/computing.org"))))
          ))
  
  (defun org-agenda-format-date-aligned-dan (date)
    "Dan's modified version of `org-agenda-format-date-aligned'.
    
    Format a date string for display in the daily/weekly agenda, or
    timeline.  This function makes sure that dates are aligned for
    easy reading.
    "
    (require 'cal-iso)
    (let* ((dayname (calendar-day-name date))
           (day (cadr date))
           (day-of-week (calendar-day-of-week date))
           (month (car date))
           (monthname (calendar-month-name month))
           (year (nth 2 date))
           (iso-week (org-days-to-iso-week
                      (calendar-absolute-from-gregorian date)))
           (weekyear (cond ((and (= month 1) (>= iso-week 52))
                            (1- year))
                           ((and (= month 12) (<= iso-week 1))
                            (1+ year))
                           (t year)))
           (weekstring (if (= day-of-week 1)
                           (format " W%02d" iso-week)
                         "")))
    ;;;     (format "%-10s %2d %s %4d%s"
    ;;;         dayname day monthname year weekstring)
      
      (format "%s %2d %s"
              (substring dayname 0 3) day (substring monthname 0 3))))
  
  (setq org-agenda-format-date 'org-agenda-format-date-aligned-dan)
#+end_src

*** Export
**** General
#+begin_src emacs-lisp
  (setq org-export-htmlize-output-type (if t 'inline-css 'css))
  (unless (member "svg" org-export-html-inline-image-extensions)
    (setq org-export-html-inline-image-extensions
          (cons "svg" org-export-html-inline-image-extensions)))
  
  (setq org-export-with-LaTeX-fragments t)
  (setq org-export-copy-to-kill-ring nil)
  (setq org-export-allow-BIND t)
  
  ;; from Eric
  (setq org-export-html-style
  "<style type=\"text/css\">
  pre {
      border: 1pt solid #AEBDCC;
      background-color: #232323;
      color: #E6E1DC;
      padding: 5pt;
      font-family: courier, monospace;
      font-size: 90%;
      overflow:auto;
  }
  </style>")
  
  ;; (setq org-export-html-style
  ;; "<style type=\"text/css\">
  ;; pre {
  ;;     border: 1pt solid #AEBDCC;
  ;;     padding: 5pt;
  ;;     font-family: courier, monospace;
  ;;     font-size: 90%;
  ;;     overflow:auto;
  ;; }
  ;; </style>")
#+end_src
**** Latex
***** Latex export hook
      [[mairix:t:@@87iq7fy0q0.fsf@totally-fudged-out-message-id][Email from Dan Davison: Re: {Orgmode} export-latex-fin]]
#+begin_src emacs-lisp
  (defun  dan/push-latex-to-odt ()
    "Convert exported .text to .odt and open in openoffice."
    (let* ((file-name (file-name-sans-extension (buffer-name)))
           (output-buffer "*latex-to-odt output*")
           (cmd (format  "mk4ht oolatex %s.tex && ooffice %s.odt"
                        file-name file-name)))
      (message "Converting latex to odt")
      (start-process-shell-command
       "latex-to-odt" output-buffer cmd)))
  
  (defun  dan/compile-latex ()
    "Convert exported .text to dvi"
    (let* ((file-name (file-name-sans-extension (buffer-name)))
           (output-buffer "*latex-to-dvi output*")
           (cmd (format  "latex %s.tex"
                         file-name file-name)))
      (message cmd)
      (start-process-shell-command
       "latex" output-buffer cmd)))
  
  ;; (add-hook 'org-export-latex-after-save-hook
  ;;           'dan/compile-latex)
#+end_src

***** Listings
***** Minted
#+begin_src emacs-lisp :tangle no :results silent
  (setq org-export-latex-minted t)
  (add-to-list 'org-export-latex-packages-alist '("" "minted"))
  (setq org-latex-to-pdf-process
        '("pdflatex --shell-escape -interaction nonstopmode %s"))
#+end_src

**** HTML
*** Src
#+begin_src emacs-lisp
  (defun dan/org-src-mode-hook ()
    (outline-minor-mode -1)
    (if (eq major-mode 'python-mode)
        (setq python-indent 4)))
  
  (add-hook 'org-src-mode-hook 'dan/org-src-mode-hook)
  ;; (remove-hook 'org-src-mode-hook 'dan/org-src-mode-hook)
  
  (add-to-list 'org-src-lang-modes '("C" . c))
  
  (setq org-hide-block-startup t)
  
  (setq org-src-window-setup 'reorganize-frame) ;; 'current-window 'other-window 'other-frame 'reorganize-frame
  ;; (setq org-src-window-setup 'current-window) ;; 'current-window 'other-window 'other-frame 'reorganize-frame
  
  
  (setq org-src-ask-before-returning-to-edit-buffer nil)
  
  (define-key org-src-mode-map [C-tab] 'org-edit-src-exit)
      #+end_src
**** Hide block and switch to edit buffer
#+begin_src emacs-lisp
  (defun dan/org-hide-block-and-switch-to-code-buffer (&optional arg)
    (interactive "P")
    (let* ((beg (org-babel-where-is-src-block-head)))
      (when beg
        (goto-char beg)
        (org-hide-block-toggle 'hide)
        (unless arg (org-edit-src-code)))))
#+end_src
**** Activate languages
#+begin_src emacs-lisp
  (mapc '(lambda (lang) (require (intern (format "ob-%s" lang))))
        dan/org-babel-languages)
  
  (setq swank-clojure-binary "/usr/bin/clojure")
  
  (setq org-confirm-babel-evaluate nil)
  
  (setq org-babel-default-header-args:perl '((:results . "output")))
#+end_src
**** Variables
#+begin_src emacs-lisp
  (setq org-babel-min-lines-for-block-output 10)
  
  ;; (setq org-babel-timestamp-results t)
  ;; (setq org-babel-allow-variable-references t)
#+end_src
**** dan/indent-src-block
#+begin_src emacs-lisp
(defun dan/indent-src-block ()
  (interactive)
  (org-edit-src-code)
  (indent-region (point-min) (point-max))
  (org-edit-src-exit))
#+end_src
**** dan/enclose-region-in-src-block
#+begin_src emacs-lisp
  (defun dan/enclose-region-in-src-block (&optional lang)
    (interactive)
    (let* ((beg (if (region-active-p) (region-beginning) (point)))
           (end (if (region-active-p) (region-end) (point))))
      (goto-char end)
      (unless (eq (char-before) ?\n) (insert "\n"))
      (insert "#+end_src\n")
      (goto-char beg)
      (beginning-of-line)
      (insert "#+begin_src ")
      (if lang (progn
                 (insert lang "\n")
                 (dan/indent-src-block))
        (insert "\n")
        (backward-char))))
  
  (defun dan/enclose-region-in-latex-block ()
    (interactive)
    (let* ((beg (if (region-active-p) (region-beginning) (point)))
           (end (if (region-active-p) (region-end) (point))))
      (goto-char end)
      (unless (eq (char-before) ?\n) (insert "\n"))
      (insert "#+end_latex\n")
      (save-excursion
        (goto-char beg)
        (beginning-of-line)
        (insert "#+begin_latex\n")
        (dan/indent-src-block))))
#+end_src
**** Etc
***** Edit buffer instead of block unhiding
#+begin_src emacs-lisp
  (defun org-babel-edit-special-maybe ()
    "Switch to edit buffer for block at point"
    (interactive)
    (let ((case-fold-search t))
      (if (save-excursion
            (beginning-of-line 1)
            (looking-at org-babel-src-block-regexp))
          (progn (org-edit-special)
                 t) ;; to signal that we took action
        nil))) ;; to signal that we did not
  
  (add-hook 'org-tab-first-hook 'org-babel-edit-special-maybe)
#+end_src
***** Execute src block from lang mode buffer
	Haven't tested this out much.
#+begin_src emacs-lisp
  (defun dan/org-src-execute ()
    "Execute src block to which this code belongs."
    (unless org-edit-src-from-org-mode
      (error "This is not a sub-editing buffer, something is wrong..."))
    (let ((beg org-edit-src-beg-marker))
      (save-window-excursion
        (set-buffer (marker-buffer beg))
        (goto-char beg)
        (org-babel-execute-src-block))))
#+end_src
      
#+resname:
| "R" | "python" | "ruby" | "ditaa" | "sass" |
***** R -> org
#+begin_src emacs-lisp :tangle no
  (defun dan/wrap-R-functions-in-source-blocks ()
    (interactive)
    (R-mode)
    (save-excursion
      (while (re-search-forward "\\([\.[:alnum:]]+\\)[ \t]+<-[ \t]+function" nil t)
        (goto-char (match-beginning 0))
        (insert (format "* %s\n" (match-string 1)))
        (insert "#+begin_src R\n")
        (ess-end-of-function)
        (insert "\n#+end_src\n")))
    (org-mode))
#+end_src
	
***** reset test table macro

   # 2*C-k <up> C-y <up> M-x r e - s e a r <tab> b a c <tab> RET T B L N A M
   # E RET <down> C-a C-SPC M-x r e - s e r DEL a r c h <tab> f o <tab> RET
   # T B L F M RET C-a M-x r e - r e p <tab> 4*DEL p l <tab> i n <tab>
   # 3*M-DEL <tab> r e <tab> g <tab> RET \ [ \ ] 2*RET M-x 2*<up> RET T B L
   # F M RET C-a 2*C-k <down> C-y <up>

#+srcname: name
#+begin_src emacs-lisp 
  (fset 'reset-tests
     (lambda (&optional arg) "Keyboard
     macro." (interactive "p") (kmacro-exec-ring-item (quote ([11
     11 up 25 up 134217848 114 101 45 115 101 97 114 tab 98 97 99
     tab return 84 66 76 78 65 77 69 return down 1 67108896
     134217848 114 101 45 115 101 114 backspace 97 114 99 104 tab
     102 111 tab return 84 66 76 70 77 return 1 134217848 114 101
     45 114 101 112 tab backspace backspace backspace backspace 112
     108 tab 105 110 tab M-backspace M-backspace M-backspace tab
     114 101 tab 103 tab return 92 91 92 93 return return 134217848
     up up return 84 66 76 70 77 return 1 11 11 down 25 up]
     0 "%d")) arg)))
#+end_src

***** Two-mode mode
#+begin_src emacs-lisp :tangle no
  (setq default-mode (list "org-mode" 'org-mode))
  (setq second-modes '(("python" "#+begin_src python" "#+end_src" python-mode)
                         ("emacs-lisp" "#+begin_src emacs-lisp" "#+end_src" emacs-lisp-mode)
                         ("ess" "#+begin_src R" "#+end_src" ess-mode)
                         ))
#+end_src

*** Fireforg
#+begin_src emacs-lisp :tangle no
(add-to-list 'load-path "/usr/local/src/org-etc/org-fireforg/lisp")
(require 'org-fireforg)
(org-fireforg-registry-insinuate)

#+end_src

*** Support for viewing images
I think all the below is obsolete since Carsten worked on
this. see :tangle no below and in font-lock tree

    See [[*Font%20lock][Font-lock]] section for more recent iimage fontification.
#+begin_src emacs-lisp :tangle no
  (require 'iimage)
  (setq iimage-mode-image-search-path (expand-file-name "~/"))
  ;;Match org file: links
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                             "\\)\\]")  1))
  
  (defun dan/org-toggle-iimage-in-org ()
    (interactive)
    (let ((turning-on (not iimage-mode)))
      (set-face-underline-p 'org-link (not turning-on))
      (iimage-mode (or turning-on 0))))
  
  (defun dan/iimage-mode-buffer (arg &optional refresh)
  "Display/undisplay images.
  With numeric ARG, display the images if and only if ARG is positive."
    (interactive)
    (let ((ing (if (numberp arg)
                   (> arg 0)
                 iimage-mode))
          (modp (buffer-modified-p (current-buffer)))
          file img)
      (save-excursion
        (goto-char (point-min))
        (dolist (pair iimage-mode-image-regex-alist)
          (while (re-search-forward (car pair) nil t)
            (if (and (setq file (match-string (cdr pair)))
                     (setq file (iimage-locate-file file
                                     (cons default-directory
                                           iimage-mode-image-search-path))))
                (if ing
                    (let ((img (create-image file)))
                      (add-text-properties (match-beginning 0) (match-end 0) (list 'display img))
                      (if refresh (image-refresh img)))
                  (remove-text-properties (match-beginning 0) (match-end 0) '(display)))))))
      (set-buffer-modified-p modp)))
  
  
  (set-face-underline-p 'org-link nil)
  
  (defun dan/org-iimage-refresh ()
    (interactive)
    (redisplay t)
    (set-face-underline-p 'org-link nil)
    (dan/iimage-mode-buffer 1 'refresh)
    (redisplay t))
  
  ;; (add-hook 'org-babel-after-execute-hook 'dan/org-iimage-refresh)
  ;; (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src

**** Etc
#+begin_src emacs-lisp :tangle no
  (defun dan/org-iimage (&optional arg)
    "Turn on iimage in org.
  With prefix argument, turn it off."
    (interactive "P")
    (let ((turning-on (not arg)))
      (set-face-underline-p 'org-link (not turning-on))
      (iimage-mode (or turning-on 0))))
  
  (defun dan/org-iimage-refresh-buffer ()
    "Force iimage images to refresh.
  Search loop taken from iimage-mode-buffer."
    (interactive)
    (dan/org-iimage)
    ;; (set-face-underline-p 'org-link nil)
    ;; (iimage-mode t)
    (let ((modp (buffer-modified-p (current-buffer))) file)
      (save-excursion
        (goto-char (point-min))
        (dolist (pair iimage-mode-image-regex-alist)
          (while (re-search-forward (car pair) nil t)
            (when (and (setq file (match-string (cdr pair)))
                       (setq file
                             (iimage-locate-file file
                                                 (cons default-directory
                                                       iimage-mode-image-search-path))))
              (image-refresh (create-image file))))))
      (set-buffer-modified-p modp))
    (redisplay))
#+end_src

*** Font-lock
:PROPERTIES:
:ID: 6fde328d-fb5a-4d28-a9ec-8b82e51b5d82
:END:
#+begin_src emacs-lisp :tangle no
  
  
  (defun dan/org-fontify-image-links (limit)
    "Display links to images as images.
  If the description part of the link is empty display the image,
  otherwise do nothing. This function is intended to be called
  during font-lock fontification."
    (let ((case-fold-search t) file image)
      (and dan/org-display-inline-images
           (re-search-forward
            (concat "\\[\\[file:\\(" iimage-mode-image-filename-regex "\\)\\]\\]") limit t)
           (setq file (match-string 1))
           (setq file (iimage-locate-file file (list default-directory)))
           (setq image (create-image file))
           (add-text-properties (match-beginning 0) (match-end 0) (list 'display image))
           ;; (clear-image-cache)
           (image-refresh image)
           ;; (redisplay)
           ;; (redraw-frame)
           ;; (redraw-display)
           ;; (image-refresh image)
           )))
  
  (setq dan/org-display-inline-images t)
  (add-hook 'org-font-lock-hook 'dan/org-fontify-image-links)
  
  (set-face-underline-p 'org-link nil)
  
  (defun dan/org-fontify-latex-commands (limit)
    (let ((case-fold-search t))
      (and (re-search-forward "\\\\[A-Za-z-_]+" limit t)
           (add-text-properties
            (match-beginning 0) (match-end 0)
            '(font-lock-fontified t face font-lock-function-name-face)))))
  
  (add-hook 'org-font-lock-hook 'dan/org-fontify-latex-commands)
#+end_src

*** Contrib
**** Load path
#+begin_src emacs-lisp
(add-to-list 'load-path "/usr/local/src/emacs/org-mode/contrib/lisp")
#+end_src
**** Htmlize
#+begin_src emacs-lisp
(require 'htmlize)
#+end_src

**** Org-mime
#+begin_src emacs-lisp
  (require 'org-mime)
  
  (add-hook 'message-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-htmlize)))
  
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))
#+end_src
*** External
**** Org-fold
#+begin_src emacs-lisp :tangle no
  (add-to-list 'load-path "/usr/local/src/emacs/orgfold")
  (add-to-list 'load-path "~/emacs/org-fold")
  (require 'org-fold)
#+end_src
**** Org-icons
#+begin_src emacs-lisp :tangle no
  (require 'org-icons)
  (org-icons-mode)
#+end_src

**** Org-fstree
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/org-fstree")
#+end_src

*** Etc
**** Show all including blocks
#+begin_src emacs-lisp
  (defun dan/org-show-all ()
    (interactive)
    (let ((org-hide-block-startup nil))
      (org-mode)
      (show-all)))
#+end_src

**** Temp org file
#+begin_src emacs-lisp
  (defun dan/org-switch-to-org-scratch ()
    "Put me in a new org buffer now!"
    (interactive)
    (let ((name "*Scratch Org*"))
      (pop-to-buffer
       (or (get-buffer name)
           (get-buffer-create (make-temp-file "org-scratch-buffer"))))
      (rename-buffer name))
    (unless (org-mode-p) (org-mode)))
#+end_src

**** Search in org source code
#+begin_src emacs-lisp
  (setq dan/org-mode-src-dir "/usr/local/src/emacs/org-mode")
  
  (defun dan/org-search-src ()
    "Search for REGEXP in Org-mode source code."
    (interactive)
    (lgrep
     (if (region-active-p)
         (buffer-substring (region-beginning) (region-end))
       (org-completing-read "Regexp: "))
     "*.el" (concat dan/org-mode-src-dir "/lisp")))
#+end_src

**** dan/org-edit-src-code-current-window
#+begin_src emacs-lisp
  (defun dan/org-edit-src-code (config)
    (let ((org-src-window-setup config))
      (org-edit-src-code)))
  
  (defun dan/org-edit-src-code:current-window ()
    (interactive)
    (dan/org-edit-src-code 'current-window))
  
  (defun dan/org-edit-src-code:reorganize-frame ()
    (interactive)
    (dan/org-edit-src-code 'reorganize-frame))
#+end_src

**** dan/org-edit-special
      Needs more work to keep point in sensible location, and to
      detect when inside a block.

#+begin_src emacs-lisp
  (defun dan/org-edit-special ()
    (interactive)
    (if (save-excursion
          (re-search-forward
           (concat "\\("
                   org-babel-src-block-regexp
                   "\\|"
                   "^[ \t]*|" ;; table
                   "\\)") nil t))
        (org-edit-special)
      (message "No target found")))
#+end_src

**** org-insert-link-maybe
#+begin_src emacs-lisp
  (defun org-insert-link-maybe ()
    "Insert a file link depending on the context"
    (interactive)
    (let ((case-fold-search t))
      (if (save-excursion
            (when (re-search-backward "[[:space:]]" nil t)
              (forward-char 1)
              (looking-at "\\[?\\[?file:?\\(?:[ \t\n]\\|\\'\\)")))
          (progn (replace-match "") (org-insert-link '(4)) t)
        nil)))
  
    (add-hook 'org-tab-first-hook 'org-insert-link-maybe)
#+end_src
**** Link to magit mode
      [[mairix:t:@@4A86B7D9.6080805@cs.tu-berlin.de][Email from Stephan Schmitt: {Orgmode} link to magit-status]]
#+begin_src emacs-lisp
(defun org-magit-store-link ()
  "Store a link to a directory to open with magit."
  (when (eq major-mode 'magit-mode)
    (let* ((dir default-directory)
           (link (org-make-link "magit:" dir))
	   (desc (abbreviate-file-name dir)))
      (org-store-link-props :type "magit" :link link :description desc)
      link)))

(defun org-magit-open (dir)
  "Follow a magit link to DIR."
  (require 'magit)
  (magit-status dir))

(org-add-link-type "magit" 'org-magit-open nil)
(add-hook 'org-store-link-functions 'org-magit-store-link)
#+end_src

**** Etc
#+begin_src emacs-lisp
    (defun dan/org-read-subtrees ()
      "Return subtrees as a list of strings"
      (let ((subtrees))
        (while (or (looking-at "^*") (outline-next-heading))
          (outline-mark-subtree)
          (setq subtrees (cons (buffer-substring (point) (mark)) subtrees))
          (goto-char (mark)))
        (nreverse subtrees)))
    
    (defun dan/org-reverse-subtrees ()
      "Reverse the order of all subtrees.
    
    Should start by setting restriction?
    "
      (interactive)
      (beginning-of-line)
      (let ((subtrees (dan/org-read-subtrees)))
        (beginning-of-buffer)
        (delete-region (point) (mark))
        (insert (mapconcat 'identity (nreverse subtrees) "\n"))))
#+end_src

**** Htmlize with images
Based on
https://stat.ethz.ch/pipermail/ess-help/2009-August/005478.html
by Vitalie S.
#+begin_src emacs-lisp 
  (defun dan/htmlize-buffer-with-org-images ()
    "Convert buffer to html, including embedded images."
    (interactive)
    (require 'htmlize)
    (save-excursion
      (switch-to-buffer (htmlize-buffer (current-buffer)))
      (goto-char (point-min))
      (while (re-search-forward "<span class=\"org-link\">file:\\(.+\\)</span>" nil t)
        (replace-match (concat "<img src='\\1'/>")))))
#+end_src

**** HTML email
#+begin_src emacs-lisp
  ;; Eric Schulte
  ;; 2010-03-23
  ;;
  ;; WYSWYG, html mail composition using org-mode
  ;;
  ;; For mail composed using the orgstruct-mode minor mode, this
  ;; provides a function for converting all or part of your mail buffer
  ;; to embedded html as exported by org-mode.  Call `org-mml-htmlize'
  ;; in a message buffer to convert either the active region or the
  ;; entire buffer to html.
  ;;
  
  (defun eric/org-mml-htmlize (arg)
    (interactive "P") ;; later just do <pre> wrap if prefix arg
    (let* ((region-p (org-region-active-p))
           (html-start (or (and region-p (region-beginning))
                           (save-excursion
                             (goto-char (point-min))
                             (search-forward mail-header-separator)
                             (point))))
           (html-end (or (and region-p (region-end))
                         ;; TODO: should catch signature...
                         (point-max)))
           (body (buffer-substring html-start html-end))
           (tmp-file (make-temp-name (expand-file-name "mail" "/tmp/")))
           ;; because we probably don't want to skip part of our mail
           (org-export-skip-text-before-1st-heading nil)
           ;; makes the replies with ">"s look nicer
           (org-export-preserve-breaks t)
           (html (save-excursion
                   (with-temp-buffer
                     (insert body)
                     (write-file tmp-file)
                     ;; convert to html -- mimicing org-run-like-in-org-mode
                     (eval (list 'let org-local-vars
                                 (list 'org-export-as-html nil nil nil ''string t)))))))
      (delete-region html-start html-end)
      (save-excursion
        (goto-char html-start)
        (insert
         (format
          "\n<#multipart type=alternative>\n<#part type=text/html>%s<#/multipart>\n"
          html)))))
#+end_src
** Org-buffers
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/org-buffers")
  (require 'org-buffers)
 (defun dan/set-org-buffers-visibility ()
   (if (org-buffers-state-eq :atom 'heading)
       (org-overview)))
 ;; (add-hook 'org-buffers-mode-hook 'dan/set-org-buffers-visibility)
 ;; (setq special-display-buffer-names `(,org-buffers-buffer-name))
 #+end_src

** Starter kit
#+begin_src emacs-lisp
  (setq dan/starter-kit-components-all '(bindings defuns eshell lisp misc org perl registers ruby yasnippet))
  (setq dan/starter-kit-components '(defuns))
  
  (let ((dotfiles-dir "~/emacs/emacs-starter-kit"))
    (mapcar
     'org-babel-load-file
     (mapcar
      (lambda (x) (format "%s/starter-kit-%s.org" dotfiles-dir (symbol-name x)))
      dan/starter-kit-components)))
#+end_src

** Yasnippet
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/local/src/emacs/yasnippet")
  (require 'yasnippet)
  (yas/initialize)
  (yas/load-directory "/usr/local/src/emacs/yasnippet/snippets")
  (yas/load-directory "/usr/local/src/emacs/Worg/org-contrib/babel/snippets")
#+end_src
* Key bindings
** dan/set-keys
#+begin_src emacs-lisp
  (defun dan/set-keys ()
    (interactive)
    (mapc (lambda (pair)
            (let* ((map (car pair)) (bindings (cdr pair)))
              (if (stringp map) (setq map (intern (concat map "-mode-map"))))
              (mapc (lambda (binding) (define-key (eval map) (car binding) (cdr binding))) bindings)))
          dan/key-bindings))
  
  (add-hook 'after-change-major-mode-hook
            (lambda ()
              (local-set-key [delete] 'winner-undo)
              (local-set-key [(super left)] 'winner-undo)
              (local-set-key [(super right)] 'winner-redo)))
  
  (defvar dan/key-bindings nil
    "List of all key bindings.
  This is an alist of alists. The key of the top level alist
  references a key map. If the key is a string, the string
  \"-mode-map\" is appended to it when finding the mode-map. If it
  is a symbol, it is used as is.")
#+end_src
** bindings
*** global
#+begin_src emacs-lisp
  (add-to-list 'dan/key-bindings
        '(global-map . 
                 (("\C-x\C-b" . org-buffers-list)
                 ("\C-ca" . org-agenda)
                 ("\C-cb" . org-iswitchb)
                 ("\C-n" . dan/next-line-and-indent)
                 ("\C-p" . dan/previous-line-and-indent)
                 ("\C-ca" . org-agenda)
                 ("\C-cf" . find-function)
                 ("\C-cg" . magit-status)
                 ("\C-cl" . org-store-link)
                 ("\C-cm" . dan/toggle-mode-line)
                 ("\C-cn" . dan/show-buffer-file-name)
                 ("\C-co" . dan/org-switch-to-org-scratch)
                 ("\C-cr" . replace-regexp)
                 ("\C-cs" . search-forward-symbol-at-point)
                 ("\C-cv" . revert-buffer)
                 ("\C-\M-g" . lgrep)
                 ([(control next)] . end-of-buffer)
                 ([(control prior)] . beginning-of-buffer) 
                 ([(s tab)] . lisp-complete-symbol) 
                 ("\M-(" . dan/enclose-rest-of-line-in-parentheses)
                 ("\M-n" . forward-paragraph)
                 ("\M-p" . backward-paragraph)
                 ("\M-2" . dan/insert-double-quotes)
                 ([delete] . winner-undo)
                 ([(hyper left)] . winner-undo)
                 ([(hyper right)] . winner-undo)
                 ([(super left)] . winner-undo)
                 ([(super right)] . winner-undo)
                 ([f1] . org-buffers-list)
                 ([f2] . (lambda () (interactive) (switch-to-buffer "*Group*")))
                 ([f3] . (lambda () (interactive) (switch-to-buffer "*Org Agenda*")))
                 ([f4] . (lambda () (interactive) (switch-to-buffer "*shell*")))
                 ([f5] . (lambda () (interactive) (switch-to-buffer "*Python*")))
                 ([f6] . dan/find-file-emacs-config)
                 ([f7] . dan/org-schedule-task-with-link)
                 ([f8] . org-remember)
                 ([f9] . find-tag-at-point)
                 ([f10] . delete-other-windows)
                 ([f11] . delete-window)
                 ([(control escape)] . delete-window)
                 ([(meta escape)] . delete-other-windows)
                 ([escape] . other-window))))
#+end_src
*** C
#+begin_src emacs-lisp
  (add-to-list 'dan/key-bindings
               '("c" . nil))
#+end_src
*** Ctrl-x-4
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '(ctl-x-4-map . (("t" . toggle-window-split))))
#+end_src
*** Elisp
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("emacs-lisp" .
     (("\C-cd" . edebug-defun)
      ("\C-c\C-l" . dan/eval-buffer-confirm))))
#+end_src
*** ESS
#+begin_src emacs-lisp 
  (add-to-list
   'dan/key-bindings
   '("ess" .
     (("\C-c?" . ess-display-help-on-object)
      ("\C-ca" . ess-r-args-show)
      ("\C-cd" . dan/ess-list-R-function-definitions)
      ("\C-cf" . dan/ess-insert-function-template)
      ("\C-ck" . dan/ess-kill-line-and-indent)
      ("\C-cx" . dan/ess-recover-R-process)
      ([(meta return)] . dan/ess-insert-function-template)
      ([(control return)] . ess-eval-line-and-step)
      ([(shift tab)] . ess-complete-object-name))))
  
  (add-to-list
   'dan/key-bindings
   `("inferior-ess" .
     ,(cdr (assoc "ess" dan/key-bindings))))
#+end_src
*** Gnus
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("gnus-summary" .
     (("\C-d" . dan/gnus-summary-delete-article))))
#+end_src
*** Latex
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("latex" .
     (([C-tab] . TeX-complete-symbol))))
#+end_src
*** Mml
#+begin_src emacs-lisp
(add-to-list
 'dan/key-bindings
 '("mml" .
   (("\M-q" . ded/mml-fill-paragraph))))
#+end_src
*** Org
#+begin_src emacs-lisp 
  (add-to-list
   'dan/key-bindings
   '("org" .
     (("\C-ch" . hide-subtree)
     ("\C-ct" . org-hide-block-toggle)
     ("\C-ci" . dan/org-toggle-iimage-in-org)
     ("\C-cz" . dan/org-babel-switch-to-code-with-session)
     ([(control \')] . dan/org-hide-block-and-switch-to-code-buffer))))
#+end_src
**** Eric's outline navigation bindings
	[[mairix:t:@@m2eirnzhb4.fsf@gmail.com][Email from Eric Schulte: Re: {Orgmode} Go to top node]]
#+begin_src emacs-lisp
(add-hook 'org-mode-hook
	  (lambda ()
	    (local-set-key (kbd "\M-\C-n") 'outline-next-visible-heading)
	    (local-set-key (kbd "\M-\C-p") 'outline-previous-visible-heading)
	    (local-set-key (kbd "\M-\C-u") 'outline-up-heading)))
#+end_src

*** Org Src
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("org-src" .
     (([(control \')] . org-edit-src-exit)
      ([delete] . org-edit-src-exit))))
#+end_src
*** Python
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("python" . nil))
#+end_src
*** Texinfo
#+begin_src emacs-lisp
  (add-to-list
   'dan/key-bindings
   '("texinfo" .
             (("\C-c\C-s" . dan/texinfo-show-structure))))
  
  (defun dan/texinfo-show-structure (&optional nodes-too)
    (interactive)
    (texinfo-show-structure)
    (let ((buffer-read-only nil))
      (goto-char (point-min))
      (if (re-search-forward "^ +[0-9]+:" nil t)
          (delete-region (point-min) (point-at-bol)))))
#+end_src
* My functions
** Trace functions
#+begin_src emacs-lisp
  (defun dan/trace-functions (regexp)
    "Trace functions with names matching regexp"
    ;; TODO: read regexp from minibuffer
    (interactive)
    (mapc 'trace-function
          (loop for x being the symbols
                if (and (fboundp x) (string-match regexp (symbol-name x)))
                collect x)))
#+end_src

** Debug on error
#+begin_src emacs-lisp
  (defun dan/toggle-debug-on-error ()
    (interactive)
    (setq debug-on-error (not debug-on-error)))
#+end_src

** Revert all elisp buffers
    #+begin_src emacs-lisp
      (defun dan/revert-elisp-buffers ()
        "Revert all elisp buffers"
        (interactive)
        (save-excursion
          (dolist (buf (buffer-list))
            (set-buffer buf)
            (if (eq major-mode 'emacs-lisp-mode)
                (revert-buffer)))))
    #+end_src


#+begin_src emacs-lisp
  (defun dan/looking-at-string (string)
    (interactive)
    (string-equal
     string
     (buffer-substring-no-properties (point) (+ (point) (length string)))))
  
  ;; this doesn't write anything in minibuffer...
  (defun dan/show-current-font() 
    (interactive)
    (frame-parameter nil 'font))
  
  ;; Why doesn't this work? (Says something about wrong number of arguments)
  (defun dan/indent-buffer ()
    "Indent whole buffer"
    (interactive)
    (mark-whole-buffer)
    (indent-region))
  
  (defun dan/eval-buffer-confirm ()
    (interactive)
    (save-buffer)
    (eval-buffer)
    (message "loaded buffer %s" (buffer-name)))
  
  ;; http://blog.printf.net/ find-tag-at-point I often work on the
  ;; kernel or Xorg, and I would be totally ridiculously lost with both
  ;; if I wasn't using "tags" support in my editor. Here's how it works:
  ;; you run etags over your .[ch] files (or make tags in a kernel
  ;; source dir), and it generates a TAGS index. You load that in emacs
  ;; with M-x visit-tags-table, and with the below keybinding, pressing
  ;; F10 will take you to the original definition of whichever symbol
  ;; the cursor is on, no matter where it appears in the source
  ;; tree. Within a few presses of F10, you've escaped macro hell and
  ;; found where the code that actually defines the function you're
  ;; interested in is.
  
  
  (defun find-tag-at-point ()
    "*Find tag whose name contains TAGNAME.
    Identical to `find-tag' but does not prompt for 
    tag when called interactively;  instead, uses 
    tag around or before point."
      (interactive)
      (find-tag (if current-prefix-arg
                    (find-tag-tag "Find tag: "))
                (find-tag (find-tag-default))))
  
  (defun search-forward-symbol-at-point ()
    "Search forward to next occurrence of thing at point"
    (interactive)
    (search-forward (symbol-name (symbol-at-point)) nil t)
    (backward-sexp)) ;; should be backward-symbol
  
  (defun dan/insert-double-quotes ()
    (interactive)
    (insert "\"\"")
    (backward-char))
  
  (defun quote-list-of-symbols ()
    "Place double quotes around the comma-separated,
  parenthesis-delimited list of symbols at point"
    (interactive)
    (save-excursion
      (let ((beg (search-forward "("))
            (end (save-excursion (search-forward ")"))))
        (insert "\"")
        (while (replace-regexp " *, *" "\", \"" t beg end))
        (replace-regexp " *)" "\")" t (point) (1+ end)))))
  
  (defun dan/find-defun (fun)
    (interactive "a")
    (describe-function fun)
    (other-window 1)
    (when (re-search-forward "`[^']+\.e")
        (push-button)))
  
  (defun dan/wc-region ()
    (interactive)
    (shell-command-on-region (mark) (point) "wc"))
  
  ;; http://www.emacswiki.org/cgi-bin/wiki/ToggleWindowSplit
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
  
  
    (defun byte-compile-dir (dir)
      (interactive)
      (let ((files (directory-files dir t ".*\.el" t)) file)
        (while (setq file (pop files))
          (byte-compile-file file))))
    
    
    (defun budget-eval ()
      ;; to eval yanked text in python-shell -- doesn't work
      (interactive)
      (other-buffer)
      (yank)
      (newline))
    
    ;; (defun dan/xclip-kill ()
    ;;   "kill region and place on X clipboard"
    ;;   (interactive)
    ;;   (shell-command-on-region (mark) (point) "xclip")
    ;;   (delete-region (mark) (point))) ;; don't add to kill ring
    
    ;; (defun dan/xclip-yank ()
    ;;   "yank from X clipboard and insert at point"
    ;;   (interactive)
    ;;   (shell-command "xclip -o" t))
    
    (defun dan/next-line-and-indent ()
      (interactive)
      (next-line)
      (indent-according-to-mode))
    
    (defun dan/previous-line-and-indent ()
      (interactive)
      (previous-line)
      (indent-according-to-mode))
    
    (defun dan/insert-square-brackets ()
      (interactive)
      (insert "[]")
      (backward-char))
    
    (defun dan/insert-curly-brackets ()
      (interactive)
      (insert "{}")
      (backward-char))
    
    (defun dan/enclose-sexp-in-parentheses ()
      (interactive)
      (insert "(")
      (forward-sexp)
      (insert ")"))
    
    (defun dan/enclose-rest-of-line-in-parentheses ()
      (interactive)
      (insert "(")
      (end-of-line) ;; need to account for comment on same line
      (insert ")"))
    
    (defun dan/insert-- ()
      (interactive)
      (insert "-"))
    
    (defun dan/quote-word ()
      "Surround word at point with double quotes"
      (interactive)
      (re-search-backward "[ ,(\t]" nil t)
      (forward-char) (insert "\"")
      (re-search-forward "[ ,)\t]" nil t)
      (backward-char) (insert "\""))
    
    (defun dan/compile-and-switch-to-iESS ()
      (interactive)
      (when (compile "make -k")
        (ess-switch-to-end-of-ESS)))
    
    ;;  (when (shell-command "make -k")
    
    ;; From Sacha Chua website
    (defun byte-compile-if-newer-and-load (file)
       "Byte compile file.el if newer than file.elc"
       (if (file-newer-than-file-p (concat file ".el")
                                   (concat file ".elc"))
           (byte-compile-file (concat file ".el")))
       (load file))
#+end_src
** Show buffer-file-name
#+begin_src emacs-lisp
  (defun dan/show-buffer-file-name ()
    (interactive)
    (let ((bn (buffer-name (current-buffer)))
          (bfn (buffer-file-name))
          (dd default-directory))
      (if bfn
          ;; file buffer
          (if (string= (file-name-nondirectory bfn) bn)
              ;; expected buffer name
              (if (string= (file-name-directory bfn) dd)
                  ;; expected default-directory
                  (message bn)
                ;; unexpected default-directory
                (message "buffer-file-name: %s\tdefault-directory: %s" bn dd))
            ;; unexpected buffer name
            (if (string= (file-name-directory bfn) dd)
                ;; expected default-directory
                (message "buffer-file-name: %s\tbuffer-name: %s" bfn bn)
              ;; unexpected default-directory
              (message "buffer-file-name: %s\tbuffer-name: %s\tdefault-directory: %s" bfn bn dd)))
        ;; non-file buffer
        (message "buffer-file-name: %S\tbuffer-name: %s\tdefault-directory: %s" bfn bn dd))))
#+end_src
** Format post
#+begin_src emacs-lisp
  (defun dan/format-region-for-post (start end)
    (interactive "r")
    (narrow-to-region start end)
    (goto-char (point-min))
    (while (re-search-forward "^[ \t]+" nil t)
      (replace-match ""))
    (goto-char (point-min))
    (while (re-search-forward "\\([a-zA-Z]\\)\n\\([a-zA-Z]\\)" nil t)
      (replace-match "\1 \2" t t))
    (widen))
#+end_src

** Switch windows
#+begin_src emacs-lisp
  (defun dan/switch-windows ()
    "Switch the buffers between windows"
    (interactive)
    (let ((other-window-buffer (window-buffer (next-window))))
      (set-window-buffer (next-window) (current-buffer))
      (set-window-buffer (selected-window) other-window-buffer)))
#+end_src

** Find-file emacs.org
#+begin_src emacs-lisp
  (defun dan/find-file-emacs-config ()
    (interactive)
    (find-file "~/.emacs.org"))
#+end_src

** Etc
#+begin_src emacs-lisp
  ;; (setq custom-file "~/src/config/emacs/emacs.el") ;; now code
  ;; generated by emacs' customisation buffers will go in this file rather
  ;; than ~/.emacs
  
  ;; Kevin Rodgers help-gnu-emacs
  ;; eldoc/timer can be used somehow to control how long messages appear for
  ;; (add-hook 'post-command-hook 'eldoc-schedule-timer nil t)
  ;; (add-hook 'pre-command-hook 'eldoc-pre-command-refresh-echo-area t)
  ;; (setq eldoc-timer [nil 1000000 0 500000 t eldoc-print-current-symbol-info nil t]) ;;
#+end_src
* Start-up
#+begin_src emacs-lisp
  ;;(when (string-match "^23\.*" emacs-version)
  ;; temp hack to make w3m work with emacs23
  ;; (require 'w3m-e21)
  ;; (provide 'w3m-e23))
  
  ;; (org-fireforg-registry-initialize t)
  
  (nnmairix-update-database)
  (dan/set-keys)
  (if nil
      (org-agenda-list)
    (delete-other-windows))
  (color-theme-initialize)
  (color-theme-charcoal-black)
  (set-face-attribute 'default nil :height 110 :family "DejaVu Sans Mono")
  (dan/sanitise-faces)
  (dan/set-show-paren-style)
  (server-start)
#+end_src

* Experimental
#+begin_src emacs-lisp
  (setq scroll-preserve-screen-position :always
        scroll-conservatively           most-positive-fixnum
        scroll-step                     0)
  
  (setq org-src-fontify-natively t)
#+end_src
** Redefine message
#+begin_src emacs-lisp :tangle no
  (defun message (format-string &rest args)
    "Redfine message to write to *Messages* buffer only"
    (set-buffer "*Messages*")
    (goto-char (point-max))
    (insert (apply 'format format-string args)))
#+end_src
* Not used
:PROPERTIES:
:tangle: no
:END:
** Customize stuff
#+begin_src emacs-lisp :tangle no
  ;; (custom-set-variables
  ;;   ;; custom-set-variables was added by Custom.
  ;;   ;; If you edit it by hand, you could mess it up, so be careful.
  ;;   ;; Your init file should contain only one such instance.
  ;;   ;; If there is more than one, they won't work right.
  ;;  '(safe-local-variable-values (quote ((org-export-latex-image-default-option . "width=30em") (org-export-latex-image-default-option . "width=100em") (org-babel-default-header-args (:tangle . "wtccc2-pca.py")) (org-babel-default-header-args (:tangle . "wtccc2-pca.py") (:exports . "code")) (org-babel-default-header-args (:results . "replace output") (:session . "*R - jsmr*") (:exports . "none")) (org-babel-default-header-args (:results . "replace output") (:session . "*R: wtccc2*") (:exports . "none")) (noweb-default-code-mode . R-mode) (org-src-preserve-indentation . t) (org-edit-src-content;; -indentation . 0) (outline-minor-mode)))))
  ;; (custom-set-faces
  ;;   ;; custom-set-faces was added by Custom.
  ;;   ;; If you edit it by hand, you could mess it up, so be careful.
  ;;   ;; Your init file should contain only one such instance.
  ;;   ;; If there is more than one, they won't work right.
  ;;  '(default ((t (:inherit nil :stipple nil
  ;;                          :background "Grey15" :foreground "Grey"
  ;;                          :inverse-video nil :box nil
  ;;                          :strike-through nil :overline nil :underline nil :slant normal 
  ;;                          :weight normal :height 120 :width normal
  ;;                          :foundry "unknown" :family "DejaVu Sans Mono"))))
  ;;  '(gnus-cite-1 ((((class color) (background light)) (:foreground "deep sky blue")))))
#+end_src

* File config
#+babel: results silent
